<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rag Doll Arena – Lab Sandbox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: #fff;
    }
    #gameCanvas {
      display: block;
      background: #05060a;
    }
    .ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 6px 10px;
      box-sizing: border-box;
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
    }
    .title {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 22px;
      letter-spacing: 2px;
      text-align: center;
      text-shadow: 0 0 12px #00e5ff;
      pointer-events: none;
      opacity: 0.12;
    }
    .hint {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: #aaa;
      text-align: center;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div class="ui-overlay">
    <div>Rag Doll Arena – Lab Sandbox</div>
    <div>Touch & drag ragdolls, tables, beakers</div>
  </div>
  <div class="title">RAG DOLL ARENA</div>
  <div class="hint">Drag limbs, tables, and beakers with your finger.</div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      setupLab();
    });

    // ---------- PHYSICS SETTINGS ----------
    const GRAVITY = 0.0015;
    const FLOOR_Y = () => height - 40;

    // ---------- RAGDOLL ----------
    function createRagdoll(x, y, scale = 1, color = '#ffffff') {
      const s = scale;
      const points = {
        torso: { x, y, vx: 0, vy: 0, r: 7 * s },
        head: { x, y: y - 20 * s, vx: 0, vy: 0, r: 6 * s },
        leftHand: { x: x - 14 * s, y: y - 4 * s, vx: 0, vy: 0, r: 4 * s },
        rightHand: { x: x + 14 * s, y: y - 4 * s, vx: 0, vy: 0, r: 4 * s },
        leftFoot: { x: x - 8 * s, y: y + 20 * s, vx: 0, vy: 0, r: 4 * s },
        rightFoot: { x: x + 8 * s, y: y + 20 * s, vx: 0, vy: 0, r: 4 * s }
      };

      const bones = [
        ['head', 'torso', 20 * s],
        ['torso', 'leftHand', 16 * s],
        ['torso', 'rightHand', 16 * s],
        ['torso', 'leftFoot', 22 * s],
        ['torso', 'rightFoot', 22 * s]
      ];

      return {
        points,
        bones,
        color,
        alive: true
      };
    }

    function applyRagdollPhysics(ragdoll, dt) {
      const pts = ragdoll.points;
      for (const key in pts) {
        const p = pts[key];
        p.vy += GRAVITY * dt;
        p.x += p.vx * (dt / 16);
        p.y += p.vy * (dt / 16);

        // floor
        if (p.y + p.r > FLOOR_Y()) {
          p.y = FLOOR_Y() - p.r;
          p.vy *= -0.25;
          p.vx *= 0.8;
        }
      }

      // simple constraints
      for (let i = 0; i < 3; i++) {
        ragdoll.bones.forEach(([aKey, bKey, dist]) => {
          const a = pts[aKey];
          const b = pts[bKey];
          let dx = b.x - a.x;
          let dy = b.y - a.y;
          let d = Math.hypot(dx, dy) || 0.0001;
          const diff = (d - dist) / d;
          const adjust = 0.5;
          dx *= diff * adjust;
          dy *= diff * adjust;
          a.x += dx;
          a.y += dy;
          b.x -= dx;
          b.y -= dy;
        });
      }
    }

    function drawRagdoll(ragdoll) {
      const pts = ragdoll.points;
      ctx.strokeStyle = ragdoll.color;
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';

      // glow
      const torso = pts.torso;
      const glow = ctx.createRadialGradient(torso.x, torso.y, 0, torso.x, torso.y, 50);
      glow.addColorStop(0, ragdoll.color);
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(torso.x, torso.y, 50, 0, Math.PI * 2);
      ctx.fill();

      // bones
      ragdoll.bones.forEach(([aKey, bKey]) => {
        const a = pts[aKey];
        const b = pts[bKey];
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      });

      // joints
      for (const key in pts) {
        const p = pts[key];
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
      }
    }

    // ---------- OBJECTS (TABLES + BEAKERS) ----------
    const objects = []; // {type, x,y,w,h,r,vx,vy,draggable}

    function createTable(x, y, w, h) {
      objects.push({
        type: 'table',
        x, y, w, h,
        vx: 0, vy: 0,
        draggable: true,
        static: false
      });
    }

    function createBeaker(x, y, r) {
      objects.push({
        type: 'beaker',
        x, y, r,
        vx: 0, vy: 0,
        draggable: true,
        static: false
      });
    }

    function applyObjectPhysics(obj, dt) {
      if (obj.static) return;

      if (obj.type === 'table') {
        // tables are heavy, no gravity unless falling
        obj.vy += GRAVITY * 0.3 * dt;
        obj.x += obj.vx * (dt / 16);
        obj.y += obj.vy * (dt / 16);

        if (obj.y + obj.h > FLOOR_Y()) {
          obj.y = FLOOR_Y() - obj.h;
          obj.vy *= -0.2;
          obj.vx *= 0.8;
        }
      } else if (obj.type === 'beaker') {
        obj.vy += GRAVITY * dt;
        obj.x += obj.vx * (dt / 16);
        obj.y += obj.vy * (dt / 16);

        if (obj.y + obj.r > FLOOR_Y()) {
          obj.y = FLOOR_Y() - obj.r;
          obj.vy *= -0.3;
          obj.vx *= 0.8;
        }
      }
    }

    function drawObject(obj) {
      if (obj.type === 'table') {
        // lab table
        ctx.fillStyle = '#2b2f3a';
        ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
        ctx.fillStyle = '#3f4656';
        ctx.fillRect(obj.x, obj.y, obj.w, 6); // top edge
      } else if (obj.type === 'beaker') {
        // glowing beaker
        const g = ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, obj.r * 2);
        g.addColorStop(0, '#00e5ff');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(obj.x, obj.y, obj.r * 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#aaf7ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(obj.x, obj.y, obj.r, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    // ---------- LAB BACKGROUND ----------
    function drawLabBackground() {
      // gradient wall
      const g = ctx.createLinearGradient(0, 0, 0, height);
      g.addColorStop(0, '#0b1018');
      g.addColorStop(0.4, '#111827');
      g.addColorStop(1, '#05060a');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, width, height);

      // floor line
      ctx.fillStyle = '#1f2937';
      ctx.fillRect(0, FLOOR_Y(), width, height - FLOOR_Y());

      // wall panels
      ctx.strokeStyle = 'rgba(80,100,140,0.4)';
      ctx.lineWidth = 1;
      for (let x = 0; x < width; x += 80) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, FLOOR_Y());
        ctx.stroke();
      }
      for (let y = 40; y < FLOOR_Y(); y += 60) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      // glowing lab panels
      for (let i = 0; i < 4; i++) {
        const px = (i + 0.5) * (width / 4);
        const py = 60;
        const pw = 80;
        const ph = 20;
        const grad = ctx.createLinearGradient(px - pw / 2, py, px + pw / 2, py + ph);
        grad.addColorStop(0, 'rgba(0,229,255,0.2)');
        grad.addColorStop(1, 'rgba(0,229,255,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(px - pw / 2, py, pw, ph);
      }
    }

    // ---------- WORLD SETUP ----------
    const ragdolls = [];

    function setupLab() {
      ragdolls.length = 0;
      objects.length = 0;

      // spawn a couple of ragdolls
      ragdolls.push(createRagdoll(width * 0.35, FLOOR_Y() - 60, 1, '#ffffff'));
      ragdolls.push(createRagdoll(width * 0.65, FLOOR_Y() - 60, 1, '#ff66ff'));

      // tables
      createTable(width * 0.2 - 80, FLOOR_Y() - 80, 160, 20);
      createTable(width * 0.8 - 80, FLOOR_Y() - 120, 160, 20);

      // beakers on/near tables
      createBeaker(width * 0.2, FLOOR_Y() - 100, 10);
      createBeaker(width * 0.8, FLOOR_Y() - 140, 10);
      createBeaker(width * 0.5, FLOOR_Y() - 60, 12);
    }

    setupLab();

    // ---------- INTERACTION (TOUCH / MOUSE) ----------
    let pointerDown = false;
    let pointerId = null;
    let dragTarget = null; // {type: 'ragdoll'|'object', ragdoll, pointKey, object}
    let lastPointerPos = { x: 0, y: 0 };
    let lastPointerTime = 0;

    function getEventPos(e) {
      if (e.touches && e.touches[0]) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      } else if (e.changedTouches && e.changedTouches[0]) {
        return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
      } else {
        return { x: e.clientX, y: e.clientY };
      }
    }

    function onPointerDown(e) {
      e.preventDefault();
      const pos = getEventPos(e);
      pointerDown = true;
      lastPointerPos = pos;
      lastPointerTime = performance.now();

      // find closest ragdoll joint
      let best = null;
      let bestDist = 999999;

      ragdolls.forEach(r => {
        for (const key in r.points) {
          const p = r.points[key];
          const dx = pos.x - p.x;
          const dy = pos.y - p.y;
          const d = Math.hypot(dx, dy);
          if (d < p.r * 2.5 && d < bestDist) {
            bestDist = d;
            best = { type: 'ragdoll', ragdoll: r, pointKey: key };
          }
        }
      });

      // if no joint, try objects
      if (!best) {
        objects.forEach(o => {
          if (!o.draggable) return;
          if (o.type === 'table') {
            if (pos.x >= o.x && pos.x <= o.x + o.w &&
                pos.y >= o.y && pos.y <= o.y + o.h) {
              best = { type: 'object', object: o };
            }
          } else if (o.type === 'beaker') {
            const dx = pos.x - o.x;
            const dy = pos.y - o.y;
            const d = Math.hypot(dx, dy);
            if (d < o.r * 2) {
              best = { type: 'object', object: o };
            }
          }
        });
      }

      dragTarget = best;
    }

    function onPointerMove(e) {
      if (!pointerDown || !dragTarget) return;
      e.preventDefault();
      const pos = getEventPos(e);
      const now = performance.now();
      const dt = now - lastPointerTime || 16;

      const vx = (pos.x - lastPointerPos.x) / (dt / 16);
      const vy = (pos.y - lastPointerPos.y) / (dt / 16);

      if (dragTarget.type === 'ragdoll') {
        const p = dragTarget.ragdoll.points[dragTarget.pointKey];
        p.x = pos.x;
        p.y = pos.y;
        p.vx = vx * 0.4;
        p.vy = vy * 0.4;
      } else if (dragTarget.type === 'object') {
        const o = dragTarget.object;
        o.x += (pos.x - lastPointerPos.x);
        o.y += (pos.y - lastPointerPos.y);
        o.vx = vx * 0.4;
        o.vy = vy * 0.4;
      }

      lastPointerPos = pos;
      lastPointerTime = now;
    }

    function onPointerUp(e) {
      e.preventDefault();
      pointerDown = false;
      dragTarget = null;
    }

    canvas.addEventListener('touchstart', onPointerDown, { passive: false });
    canvas.addEventListener('touchmove', onPointerMove, { passive: false });
    canvas.addEventListener('touchend', onPointerUp, { passive: false });
    canvas.addEventListener('mousedown', onPointerDown);
    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);

    // ---------- COLLISIONS: RAGDOLL vs TABLES ----------
    function handleRagdollTableCollisions(ragdoll) {
      const pts = ragdoll.points;
      objects.forEach(o => {
        if (o.type !== 'table') return;
        const top = o.y;
        const bottom = o.y + o.h;
        const left = o.x;
        const right = o.x + o.w;

        for (const key in pts) {
          const p = pts[key];
          // only handle from above
          if (p.x > left && p.x < right && p.y + p.r > top && p.y < top) {
            p.y = top - p.r;
            p.vy = Math.min(p.vy, 0) * -0.2;
            p.vx *= 0.8;
          }
        }
      });
    }

    // ---------- MAIN LOOP ----------
    let lastTime = performance.now();

    function update(dt) {
      // physics
      ragdolls.forEach(r => {
        applyRagdollPhysics(r, dt);
        handleRagdollTableCollisions(r);
      });

      objects.forEach(o => {
        applyObjectPhysics(o, dt);
      });
    }

    function draw() {
      drawLabBackground();

      // objects behind ragdolls
      objects.forEach(drawObject);

      // ragdolls
      ragdolls.forEach(drawRagdoll);
    }

    function loop(timestamp) {
      const dt = timestamp - lastTime;
      lastTime = timestamp;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>

   
